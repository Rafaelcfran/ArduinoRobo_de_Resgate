class DCMotor {
  int spd = 255, pin1, pin2, enable;

public:
  void Pinout(int in1, int in2, int enb) {
    pin1 = in1;
    pin2 = in2;
    enable = enb;
    pinMode(pin1, OUTPUT);
    pinMode(pin2, OUTPUT);
    pinMode(enable, OUTPUT);
  }

  void Forward(int speed) {
    spd = speed;
    digitalWrite(pin1, LOW);
    digitalWrite(pin2, HIGH);
    analogWrite(enable, spd);
    delay(25);

    digitalWrite(pin1, LOW);
    digitalWrite(pin2, LOW);
    analogWrite(enable, spd);
    delay(25);
  }

  void Backward(int speed) {
    spd = speed;
    digitalWrite(pin1, HIGH);
    digitalWrite(pin2, LOW);
    analogWrite(enable, spd);
    delay(25);
    digitalWrite(pin1, LOW);
    digitalWrite(pin2, LOW);
    analogWrite(enable, spd);
    delay(25);
  }

  void Stop() {
    digitalWrite(pin1, LOW);
    digitalWrite(pin2, LOW);
    analogWrite(enable, 0);
  }
};

DCMotor Motor1, Motor2;
//Motor 2 = motor esquerdo
//Motor 1 = motor direito
int estadoAtual, estadoAnterior;
#define ESTADO_PARADO 0
#define ESTADO_FRENTE 1
#define ESTADO_DIREITA 2
#define ESTADO_ESQUERDA 3
#define ESTADO_TRAS -1

void forward() {
  Motor1.Forward(255);
  Motor2.Forward(255);
}

void curvaesq() {
  // Só direito detecta a linha → virar para esquerda
  Motor1.Forward(255);
  // direito para frente
  Motor2.Stop();  // esquerdo para trás
}

void curvadir() {
  // Só esquerdo detecta a linha → virar para direita
  Motor2.Forward(255);  // esquerdo para frente
  Motor1.Stop();        // direito para trás
}


void stop() {
  Motor1.Stop();
  Motor2.Stop();
}

void backward() {
  Motor1.Backward(255);
  Motor2.Backward(255);
}

const int pinoTrig = 10;  // Pino do Trigger
const int pinoEcho = 11;  // Pino do Echo
unsigned long UScontadorMillis = millis();
unsigned long UScontadorMicros = micros();
float distancia;

int leituraIRe, leituraIRd, leituraIRpontaD, leituraIRpontaE;
int pinoIRpontaE = 12, pinoIRpontaD = 11, pinoIRe = 2, pinoIRd = 3;
bool flagdir = false, flagesq = false;
unsigned long IRcontadorMillis = millis();


void setup() {
  Motor1.Pinout(5, 4, 6);
  Motor2.Pinout(7, 8, 9);
  Serial.begin(9600);
  int estadoAtual = ESTADO_PARADO;
  int estadoAnterior = ESTADO_PARADO;
  // pinMode(pinoEcho, INPUT);
  // pinMode(pinoTrig, OUTPUT);
  // digitalWrite(pinoTrig, LOW);
}

void loop() {


  //    if((millis() - UScontadorMillis) >= 1000 && digitalRead(pinoTrig) == LOW) {
  //        digitalWrite(pinoTrig, HIGH);
  //        UScontadorMillis = millis();
  //        UScontadorMicros = micros();
  //    }
  //    if((micros() - UScontadorMicros) >= 10 && digitalRead(pinoTrig) == HIGH) {
  //        digitalWrite(pinoTrig, LOW);
  //        float deltaT = pulseIn(pinoEcho,HIGH);
  //        distancia = deltaT * 0.034 / 2 ;
  //        //Serial.print("Distancia em cm: ");
  //        //Serial.println(distancia);
  //    }

  leituraIRe = digitalRead(pinoIRe);
  leituraIRpontaD = digitalRead(pinoIRpontaD);
  leituraIRpontaE = digitalRead(pinoIRpontaE);
  leituraIRd = digitalRead(pinoIRd);

  if (leituraIRpontaD == HIGH) {
    flagdir = true;
  }


  if (leituraIRpontaE == HIGH) flagesq = true;

  if ((millis() - IRcontadorMillis) >= 100) {
    Serial.print("leitura da infra da flag esquerda é ");
    Serial.println(leituraIRpontaE);
    Serial.print("leitura da flag esquerda é ");
    Serial.println(flagesq);
    Serial.print("leitura do infra esquerdo: ");
    Serial.println(leituraIRe);
    Serial.print("leitura do infra da flag direita é ");
    Serial.println(leituraIRpontaD);
    Serial.print("leitura da flag direito é ");
    Serial.println(flagdir);
    Serial.print("leitura do infra direito: ");
    Serial.println(leituraIRd);
    Serial.println(" ");
    IRcontadorMillis = millis();
  }

  // if (flagdir == true) {
  //   estadoAtual = ESTADO_DIREITA;
  // } else {
  //   if (leituraIRd == HIGH) {
  //     // detecta para fazer curva para a direita
  //     flagesq = false;
  //     estadoAtual = ESTADO_DIREITA;
  //   }
  // }

  // if (flagesq == true) {
  //   estadoAtual = ESTADO_ESQUERDA;
  // } else {
  //   if (leituraIRe == HIGH) {
  //     // detecta para fazer curva para a esquerda
  //     flagdir = false;
  //     estadoAtual = ESTADO_ESQUERDA;
  //   }
  // }

  // if ((leituraIRd == LOW && leituraIRe == LOW) && (flagdir == false && flagesq == false)) {
  //   estadoAtual = ESTADO_FRENTE;
  // }

  // ------------------------------------------- Prioridade da Lógica de Estado ------------------------------------------

  // 1. Condições de Parada ou Perda Total da Linha (maior prioridade)



  if (leituraIRpontaD == HIGH && leituraIRpontaE == HIGH) {  // Ambas as pontas detectam
    estadoAtual = ESTADO_PARADO;                             // Robô encontrou uma encruzilhada ou o fim da linha
    // Resete as flags para o próximo ciclo, já que essa situação foi tratada
    flagdir = false;
    flagesq = false;
  }
  // Se ambos os sensores laterais (principais) estão fora da linha E as flags de ponta estão inativas,
  // o robô pode ter saído completamente da linha ou estar em um ponto cego.
  else if ((leituraIRd == LOW && leituraIRe == LOW) && (flagdir == false && flagesq == false)) {
    estadoAtual = ESTADO_FRENTE;  // Ou ESTADO_TRAS para tentar voltar
  }

  // 2. Curvas Acentuadas ou Detecção de Ponta (prioridade intermediária)


  // Se a flag de direita ou o sensor de ponta direita está ativo
  else if (flagdir == true || leituraIRpontaD == HIGH) {
    estadoAtual = ESTADO_DIREITA;  // Gira para a direita
    // Resete a flag depois de usá-la, para que a decisão seja baseada em novas leituras
    // ou se a condição de curva é contínua.
    // Ajuste isso se a flag deve persistir por mais tempo
    flagesq = false;  // Garante que a outra flag não interfere se já era true
  }
  // Se a flag de esquerda ou o sensor de ponta esquerda está ativo
  else if (flagesq == true || leituraIRpontaE == HIGH) {
    estadoAtual = ESTADO_ESQUERDA;  // Gira para a esquerda
    // Resete a flag

    flagdir = false;  // Garante que a outra flag não interfere se já era true
  }

  // 3. Seguindo a Linha Normalmente (prioridade mais baixa - padrão)
  // Se nenhuma das condições acima for atendida, o robô está sobre a linha ou precisa de pequenas correções.

  // Se o sensor direito detecta a linha (robô desviando para a esquerda, precisa virar à direita)
  else if (leituraIRd == HIGH && leituraIRe == LOW) {  // Apenas sensor direito na linha
    estadoAtual = ESTADO_DIREITA;
  }
  // Se o sensor esquerdo detecta a linha (robô desviando para a direita, precisa virar à esquerda)
  else if (leituraIRe == HIGH && leituraIRd == LOW) {  // Apenas sensor esquerdo na linha
    estadoAtual = ESTADO_ESQUERDA;
  }
  // Se ambos os sensores laterais (principais) estão na linha, ou ambos estão fora (mas não na condição de parada total)
  // Isso geralmente significa que o robô está centralizado na linha.
  //else if (leituraIRe == HIGH && leituraIRd == HIGH) estadoAtual = ESTADO_FRENTE;

  // Caso nenhum dos sensores esteja na linha e não ativou as flags de ponta,

  else
    estadoAtual = ESTADO_PARADO;  // Ou mantenha o estado anterior: estadoAtual = estadoAnterior;


  if (estadoAtual != estadoAnterior) {
    /*if(flagdir == true && flagesq == true && estadoAnterior == ESTADO_DIREITA){
      flagesq= false;
      estadoAtual = estadoAnterior;
    }else  if(flagdir == true && flagesq == true && estadoAnterior == ESTADO_ESQUERDA){
      flagdir= false;
      estadoAtual = estadoAnterior;
    
    }else*/
    estadoAnterior = estadoAtual;
  }
  switch (estadoAtual) {
    case ESTADO_FRENTE:
      forward();
      break;

    case ESTADO_PARADO:
      stop();
      break;

    case ESTADO_DIREITA:
      curvadir();
      break;

    case ESTADO_ESQUERDA:
      curvaesq();
      break;

    case ESTADO_TRAS:
      backward();
      break;
  }
}
